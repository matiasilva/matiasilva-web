<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/bulma@0.9.1/css/bulma.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@creativebulma/bulma-divider@1.1.0/dist/bulma-divider.min.css><link rel=stylesheet href=/css/fontawesome/all.css><link rel=stylesheet href=/css/style.css><title>Beginner's guide to PWM on the Pico | matias silva</title></head><body><nav class="navbar has-shadow" role=navigation aria-label="main navigation"><div class=container><div class=navbar-brand><a class=navbar-item href=/><span class=ms-navbar-text>matiasilva.com</span></a>
<a role=button class="navbar-burger burger" aria-label=menu aria-expanded=false data-target=navbarBasicExample><span aria-hidden=true></span><span aria-hidden=true></span><span aria-hidden=true></span></a></div><div id=navbarBasicExample class=navbar-menu><div class=navbar-start><a href=/about/ class=navbar-item>About</a>
<a href=/projects/ class=navbar-item>Projects</a>
<a href=/journal/ class=navbar-item>Journal</a></div><div class=navbar-end><div class=navbar-item><div class=buttons><a class="button is-info" href=/files/matias_cv_2021.pdf><i class="fas fa-file mr-2"></i>CV</a>
<a class="button is-dark" href=https://github.com/matiasilva><i class="fab fa-github mr-2"></i>GitHub</a></div></div></div></div></div></nav><main><section class="container section is-max-desktop"><article class="is-flex is-flex-direction-row is-justify-content-space-between is-align-items-center block"><div><h1 class="title is-2">Beginner's guide to PWM on the Pico</h1></div><div><p class="subtitle is-6 has-text-grey"><span class=icon><i class="far fa-calendar-alt"></i></span>March 15, 2021</p></div></article><article class=content><p>The Raspberry Pi Pico is an accessible ARM Cortex-based micro-controller for makers. It&rsquo;s jam-packed with cool stuff, one of which is its PWM blocks. In this brief guide I go over how the PWM functionality of the Pico works and a few PWM basics. This hopefully helps fill in more of the gaps that exist out there in the C/C++ programming guides for the Pico.</p><h2 id=what-is-pwm>What is PWM?</h2><p>Pulse width modulation (PWM) is a technique used to create analog-like signals when working with digital devices, like micro-controllers. The output signal looks like a square wave since it can only take two possible values: logic high or logic low. These correspond to different voltage levels on different micro-controllers and on the Pico this corresponds to 0V and 3.3V.</p><p>There are two key parameters when it comes to PWM: frequency and duty cycle.</p><ul><li><strong>frequency</strong>: how many cycles (ie, an on followed by an off or the smallest &ldquo;unit&rdquo; of the signal that repeats) take place every second</li><li><strong>duty cycle</strong>: the ratio of the on time to the total period of one signal cycle</li></ul><p>You could, for example, create a crude PWM signal by just turning the Pico&rsquo;s GPIOs on and off and sleeping a few milliseconds in between. This could look something like:</p><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=n>gpio_put</span><span class=p>(</span><span class=n>MY_PIN</span><span class=p>,</span> <span class=n>HIGH</span><span class=p>);</span>
<span class=n>sleep_ms</span><span class=p>(</span><span class=mi>100</span><span class=p>);</span>
<span class=n>gpio_put</span><span class=p>(</span><span class=n>MY_PIN</span><span class=p>,</span> <span class=n>LOW</span><span class=p>);</span>
<span class=n>sleep_ms</span><span class=p>(</span><span class=mi>200</span><span class=p>);</span>
</code></pre></div><p>Then, your duty cycle would be 33% since one full cycle spends 100ms high and 200ms low. There are many problems with the above approach: it&rsquo;s blocking, it&rsquo;s slow but most importantly the Pico has dedicated hardware to do this!</p><h2 id=pwm-slices-and-registers>PWM slices and registers</h2><p>The Pico has 8 PWM slices, numbered 0-7, that have two channels each, numbered 0 and 1 (but you should use the <code>pwm_chan</code> enum values like <code>PWM_CHAN_A</code> in code). A slice is nothing but a dedicated &ldquo;unit&rdquo; of the PWM block with its own internal 16-bit counter and 16-bit compare registers (one for each channel). A channel is a usable output that can be attached to any of the available GPIOs on the Pico (included the onboard LED -> which is very useful for debugging). You can use all slices, one single slice, or none at all.</p><p>PWM is all about timing. The basic principle of operation is the following:</p><ol><li>PWM slice is enabled by the user</li><li>The slice&rsquo;s internal counter counts up until it reaches either the wrap limit set by the user (called TOP) if set or the counter&rsquo;s limit (2^16 - 1 = 65535). After this, it &ldquo;wraps back&rdquo; to 0 and begins counting again. This is called a &ldquo;free-running&rdquo; counter.</li><li>At each increment of the internal counter, the counter value is compared to the value set in the compare register (this is called the &ldquo;level&rdquo;). If the counter value is greater than the channel&rsquo;s level, then the output drops to 0 until the counter wraps and it is set to logic high again. This repeats to give us nice square waves!</li></ol><p>The counter is based on the system&rsquo;s clock. The Pico has a central system clock, called <code>sysclock</code> in the docs, that increments with every rising edge of the board&rsquo;s oscillator. By default, the system clock&rsquo;s frequency is 133MHz. You can set a division factor (also known as a prescaler on AVR systems) that sets the rate at which the internal clock increments. For example, a factor of 4 means that for every 4 system clock increments, the slice&rsquo;s clock increments by 1.</p><p>This way we can control the duty cycle by setting a different level and we can change the frequency by changing the dividing factor, which is by default at 1 (ie, in sync with sysclock). The clock&rsquo;s wrap value also has an effect on the signal&rsquo;s frequency.</p><p>Note: the Pico&rsquo;s PWM slices can also be used to measure input signals, but I won&rsquo;t get into that in this guide just yet!</p><h2 id=programming>Programming</h2><div class="notification is-info is-light">The relevant part of the fantastic Pico C/C++ SDK documentation is "hardware_pwm" starting on page 155.
| markdownify</div><p>Naturally from the above explanation, a few parameters fall out: the channel level, the clock&rsquo;s wrap value and the dividing factor. The last two are configurable at the slice-level and the first is at the channel-level. Usually, we vary the channel level (to vary the duty cycle) but keep the slice&rsquo;s configuration constant once set. Therefore, the first step is to configure the slice.</p><p>After playing around with the SDK, I recommend using the slice configuration method, in which the two values mentioned before and a few others are encapsulated in a nice <code>struct</code>, which we pass to the slice on initialization. The other way is to individually set settings for a slice, which is OK for experimenting or if you&rsquo;re using one slice only, but using the config method is more robust, in my opinion.</p><p>One fun way to visualize the dividing factor&rsquo;s effect, is to set it to it&rsquo;s max value of 255 and attach the the built-in LED to a PWM channel. This is the slowest possible setting for the PWM and I used it to figure out how to use the SDK as I don&rsquo;t have an oscilloscope. This could look something like:</p><div class=highlight><pre class=chroma><code class=language-C data-lang=C><span class=c1>// set the built-in LED as a PWM pin
</span><span class=c1></span><span class=n>gpio_set_function</span><span class=p>(</span><span class=n>PICO_DEFAULT_LED_PIN</span><span class=p>,</span> <span class=n>GPIO_FUNC_PWM</span><span class=p>);</span>
<span class=c1>// find out which slice our LED just got allocated
</span><span class=c1></span><span class=n>uint</span> <span class=n>slice_num</span> <span class=o>=</span> <span class=n>pwm_gpio_to_slice_num</span><span class=p>(</span><span class=n>PICO_DEFAULT_LED_PIN</span><span class=p>);</span>

<span class=c1>// get a default config struct to modify
</span><span class=c1></span><span class=n>pwm_config</span> <span class=n>config</span> <span class=o>=</span> <span class=n>pwm_get_default_config</span><span class=p>();</span>
<span class=c1>// optionally change the wrap value
</span><span class=c1>// pwm_config_set_wrap(&amp;config, 3);
</span><span class=c1>// set the clock to increment only every 255 increments of sysclock
</span><span class=c1></span><span class=n>pwm_config_set_clkdiv</span><span class=p>(</span><span class=o>&amp;</span><span class=n>config</span><span class=p>,</span> <span class=mf>255.f</span><span class=p>);</span>
<span class=c1>// set a half duty cycle which is half of the counter&#39;s limit of 2^16
</span><span class=c1></span><span class=n>pwm_set_gpio_level</span><span class=p>(</span><span class=n>PICO_DEFAULT_LED_PIN</span><span class=p>,</span> <span class=mf>0.5</span> <span class=o>*</span> <span class=p>(</span><span class=mi>1</span> <span class=o>&lt;&lt;</span> <span class=mi>16</span><span class=p>));</span>
<span class=c1>// initialize the PWM wiht our config and start it right after
</span><span class=c1></span><span class=n>pwm_init</span><span class=p>(</span><span class=n>slice_num</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>config</span><span class=p>,</span> <span class=nb>true</span><span class=p>);</span>
</code></pre></div><div class="notification is-danger is-light">Make sure to add `hardware_pwm` to your `CMakeLists.txt` file so that your file knows where to find the Pico's PWM API. This looks like: `target_link_libraries(blink pico_stdlib hardware_pwm)`
| markdownify</div><p>Now all that&rsquo;s left is to compile the code and flash the board. I&rsquo;ve covered how to do that in another journal entry using a Raspberry Pi 3B+, the Pico&rsquo;s SWD pins and GDB + OpenOCD.</p><h2 id=conclusion>Conclusion</h2><p>I hope this guide helped you understand how the PWM blocks and the Pico&rsquo;s PWM API works. Make sure to read the C/C++ SDK documentation for more information on specific functions or even better give this a go!</p><p>If you find any incorrect information, please contact me on the address listed in my GitHub profile. Thanks!</p></article></section></main><footer class=footer><div class="content has-text-centered"><p class="subtitle is-6">Built (statically) by <a href=https://github.com/matiasilva>@matiasilva</a> with <a href=https://gohugo.io>Hugo</a> in 2021. Content
licensed <a href=http://creativecommons.org/licenses/by-nc-sa/4.0/>CC BY NC SA 4.0</a>.</p></div></footer><script src=/js/main.js></script></body></html>